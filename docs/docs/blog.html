<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Jiawei's Blog</title>
  <meta name="description" content="Posts on programming and systems">

  <!-- Social: Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@JWLiu10">
  <meta name="twitter:title" content="Jiawei's Blog">
  <meta name="twitter:description" content="Posts on programming and systems">
  
  <meta property="twitter:image:src" content="/assets/img/opengraph.png">
  

  <!-- Social: Facebook / Open Graph -->
  <meta property="og:url" content="/blog.html">
  <meta property="og:title" content="Jiawei's Blog">
  
  <meta property="og:image" content="/assets/img/opengraph.png">
  
  <meta property="og:description" content="Posts on programming and systems">
  <meta property="og:site_name" content="">

  <!-- Social: Schema.org  -->
  <meta itemprop="name" content="Jiawei's Blog"/>
  <meta itemprop="description" content="Posts on programming and systems">
  <meta itemprop="image" content="/assets/img/opengraph.png"/>

  <!-- Favicon -->
  <link rel="shortcut icon" href="/assets/img/icons/favicon.ico" type="image/x-icon" />

  <!-- Android Lolipop Theme Color -->
  <meta name="theme-color" content="#2a4d14">

  <!-- Styles -->
  <link rel="stylesheet" id="css-theme" href="/assets/css/main-dark.css">
  <link rel="stylesheet" href="/assets/css/highlight/monokai.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">

  <!-- Javascript -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.3.0/d3.min.js"></script>
  <script type="text/javascript" src="/assets/js/main.js"></script>
</head>


<body class="animated fadeIn">
  <div class="container">
    <div id="background-div">
      <svg id="background-svg">
        <lineargradient id="Gradient1" x1="0" x2="0" y1="0" y2="1">
          <stop stop-opacity="0" class="bgColor2" offset="0%" />
          <stop stop-opacity="0.5" class="bgColor2" offset="10%" />
          <stop stop-opacity="0.5" class="bgColor1" offset="40%" />
          <stop stop-opacity="0" class="bgColor1" offset="100%" />
        </lineargradient>
        <g id="bg-layer1"></g>
        <g id="bg-layer2" class="hide"></g>
        <g id="bg-layer3"></g>
        <g id="bg-layer4"></g>
      </svg>
    </div>
    <section class="header">
      <header>
  <div class="row">
    <div class="col-xs-12">
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
          <div class="navbar-header">
            <a class="navbar-toggle collapsed navbar-icon" data-toggle="collapse"
              data-target="#bs-example-navbar-collapse-1">
              <i class="fa fa-bars fa-2x"></i>
            </a>
            <a class="navbar-brand navbar-icon" href="/">
                <i class="fa fa-home fa-2x"></i>
            </a>
          </div>

          <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
              <li><a href="/">Home</a></li>
              
                <li><a href="/blog">Blog</a></li>
              

              
              
                <li class="nav-item"><a href="/items/pics.html">Pictures</a></li>
              

              <script>
                // clean repeated dropdowns and add <li> to their positions
                let done = [];
                let elements = [];
                $(".dropdown")
                  //
                  .each((index0 , value0) => {
                    let dropdownClass = "."+$(value0)[0].classList[1];
                    if (done.indexOf(dropdownClass) !== -1) return
                    done.push(dropdownClass)
                    let dropdownMain = $(dropdownClass)[0]
                    let itemsList = $(dropdownClass+">ul>li").sort((a, b) => parseInt(b.getAttribute("priority") || -9999999) - parseInt(a.getAttribute("priority") || -9999999))
                    $(dropdownClass+">ul>li").remove();
                    $(dropdownClass+">ul").append(itemsList)
                    $(dropdownClass).remove();
                    elements.push(dropdownMain)
                });
                let priority = [ "About", ];
                elements = elements.concat(...$(".nav-item").remove())
                priority.map(text => {
                  elements = elements.filter(node => {
                      let nodeText = node.querySelector("a").textContent.trim()
                      if (text == nodeText) {
                          $(".nav").append(node)
                          return false;
                      }
                      return true;
                  })
                });
                $(".nav").append(elements)
              </script>
            </ul>
          </div>
        </div>
      </nav>
    </div>
  </div>
</header>

    </section>
    <section class="content">
      <div class="row">
        <!-- <div class="col-sm-2">
          <div class="pane-separator hidden-xs" style="margin-bottom:30em;"></div>
          <div class="left-pane">
          </div>
        </div> -->
        <div class="col-sm-8 col-sm-offset-2 content-div">
          <div class="page-separator hidden-xs">
            <h1 class="h1-strip" style="padding-bottom:8em; margin-bottom: 0;"></h1>
          </div>
          <div class="page-separator visible-xs">
            <h1 class="h1-strip" style="padding-bottom:2em; margin-bottom: 0;"></h1>
          </div>
          <h1 class="post-title page-title" id="title"><a href="#title">Jiawei's Blog</a></h1>
          
    <a href="/blog/2021/07/09/alloc-right.html">
      <h1 class="post-title"> Allocate Stuff in the Right Way</h1>
      <h5 class="post-title"> 2021-07-09 11:07:12 -0500 </h5>
    </a>
    <p>NOTE: This article is for those who are new to code optimizations. If you have already understood the design rationale of small vectors and SOO (small object optimzation), please ignore this.</p>

<h2 id="tldr">TL;DR</h2>

<p>Try to avoid dynamic allocation in critical path. Always prefer stack/static memory, or at least leverage small vectors according to the distribution of the length of your data.</p>

<h2 id="memory-storage-types">Memory Storage Types</h2>

<p>As what you were taught in college class, there’re commonly 3 memory storage types (stuff like <code class="language-plaintext highlighter-rouge">thread_local</code> is not my story today):</p>

<p>1) <strong>static</strong>; 2) <strong>dynamic</strong> (or so-called heap memory); 3) <strong>automatic/stack</strong></p>

<h3 id="a-dummy-example">A dummy example</h3>

<p>Look at this example containing those 3 types of memory usage.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">static_var</span> <span class="p">{</span><span class="mi">233333</span><span class="p">};</span> <span class="c1">// static storage</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptr_to_dynamic_var</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">55555555</span><span class="p">};</span> <span class="c1">// dynamic storage</span>
    <span class="kt">int</span> <span class="n">stack_var</span> <span class="p">{</span><span class="mi">666666</span><span class="p">};</span> <span class="c1">// automatic/stack storage</span>
    <span class="k">delete</span> <span class="n">ptr_to_dynamic_var</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Its corresponding assembly (unused labels, lib functions, directives filtered) by GCC 11.1 in <code class="language-plaintext highlighter-rouge">-O0 -std=c++2a</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static_var:
        .long   233333 # non-const static storage variable will be stored in static data region (marked by its corresponding directive `.long`).
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16 # You can simply regard this as stack allocation, making rsp pointing to the end of current stack.
        mov     edi, 4
        call    operator new(unsigned long) # allocate dynamic memory according to `operator new` (usually libc's malloc by default)
        mov     DWORD PTR [rax], 55555555 # After dynamic allocation, we got the space and we ship the value (55555555) into the corresponding address.
        mov     QWORD PTR [rbp-8], rax
        mov     DWORD PTR [rbp-12], 666666 # Set the value of `stack_var`
        mov     rax, QWORD PTR [rbp-8]
        test    rax, rax
        je      .L2
        mov     esi, 4
        mov     rdi, rax
        call    operator delete(void*, unsigned long)
.L2:
        mov     eax, 0
        leave
        ret
</code></pre></div></div>

<p>To help you read the assembly, let’s quickly review some important X86 registers:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">%rax</code>: return value. We move the value <code class="language-plaintext highlighter-rouge">55555555</code> to <code class="language-plaintext highlighter-rouge">rax</code> which was previously set by the call <code class="language-plaintext highlighter-rouge">operator new</code>, and then we put the value of <code class="language-plaintext highlighter-rouge">rax</code> to <code class="language-plaintext highlighter-rouge">[rbp - 8]</code></li>
  <li><code class="language-plaintext highlighter-rouge">%rbp</code>: the start address of current stack (the base pointer for <code class="language-plaintext highlighter-rouge">rsp</code> (the stack pointer)). <code class="language-plaintext highlighter-rouge">[rbp - 8]</code> is where <code class="language-plaintext highlighter-rouge">ptr_to_dynamic_var</code> lives (in 64bit mode, pointers are of 8 bytes) and <code class="language-plaintext highlighter-rouge">[rbp - 12]</code> (12 = 8 + 4) is where <code class="language-plaintext highlighter-rouge">stack_var</code> lives. Make a lot more sense right?</li>
</ul>

<h3 id="some-intuitive-analysis">Some intuitive analysis</h3>

<p>The (de)allocation of static variable is super cheap, since you cannot see any instructions regarding its (de)allocation. Actually, (de)allocation to static varibles is handled by the OS (reserved by the compiler). Like the memory for the codes (instructions), it is created once the program starts and cleaned when the program ends. Hence, there’s no runtime cost of (de)allocate them.</p>

<p>Stack memory is also cheap, theoretically (let’s forget program interrupt), only 2 instruction (<code class="language-plaintext highlighter-rouge">push rbp</code> and <code class="language-plaintext highlighter-rouge">mov rbp, rsp</code>) is used to initialize the stack and 1 for “allocating” the stack frame. Since we can simply regard that we have infinite memory towards the direction of stack growth, the allocation is as cheap as moving forward a stack pointer (or statically set its offset in the assembly). The behavior of stack allocation is simply defined during compilation time since it is only relavant to your codes. It is a bit dynamic because the program during runtime can determine which path to enter. Some paths may contain a deep stack while others may not. But anyways, in general, stack allocation is quite cheap because it is also very “static”.</p>

<p>Well, as for “the type of crime”, dynamic allocation is absolutely the user’s (or input’s) call. It is your call to tell when to allocate (e.g., <code class="language-plaintext highlighter-rouge">new</code>) and deallcoate (e.g., <code class="language-plaintext highlighter-rouge">delete</code>). The cost of flexibility is complexity and efficiency. First, <strong>flexibility</strong> makes it possible to <code class="language-plaintext highlighter-rouge">new</code>/<code class="language-plaintext highlighter-rouge">delete</code> anywhere you want, however, it might not be legal or well-formed. You may kill your program out of double free, deallocating a non-exist pointer, memory leak, and many others. To avoid such issues, you finally ask for some help from <em>garbage collection</em>, <em>smart pointer</em>, and many other ownership stuffs, introducing complexity to your codes (tell me the probability of successfully compiling a rust program and how much you love <code class="language-plaintext highlighter-rouge">unsafe</code>) and some performance degradation. Second, everything is a tradeoff and “allocate anywhere” does not come for free. You or the memory allocation library (e.g., <a href="http://jemalloc.net/">jemalloc</a>) you refered to need to carefully maintain one or more logically contiguous buffer(s) to make sure either it allocates fast (monotonic allocator) or long/robust (compact allocator). The actual instructions executed in runtime behind that <code class="language-plaintext highlighter-rouge">call operator new</code> can be dramatic. Usually such mechanisms makes allocation cost unstable, it can be fast when there’s plenty of space left in the pool, but can be extremely slow when you have a huge amount of memory fragments (did you make a lot of small objects allocted with <code class="language-plaintext highlighter-rouge">malloc</code>?). Apart from this, for small objects, stack memory is always more cache-friendly than heap ones since you are always seeing something in the stack (see the example assembly) so that stack memory can be considered always on-cache.</p>

<p>In a word, dynamic memory is guilty and we should try our best to prevent it if your program is performance-critical (since our compilers at this moment cannot resolve this problem at all).</p>

<p>Also, I’d like to quote a sentence from <em>Optimized C++</em> whose author seems to hate dynamic memory way more than me:</p>

<blockquote>
  <blockquote>
    <p><em>That’s where the money is.</em></p>

    <p>—Bank robber Willie Sutton (1901–1980)</p>
  </blockquote>

  <p>This quote was attributed to Sutton as the answer to a reporter’s 1952 question, “<em>Why do you rob banks?</em>” Sutton later denied ever having said it.</p>

  <p>Except for the use of less-than-optimal algorithms, the naïve use of dynamically allocated variables is <strong>the greatest performance killer in C++ programs</strong>. Improving a program’s use of dynamically allocated variables is so often “<em>where the money is</em>” that a developer can be an effective optimizer knowing nothing other than how to reduce calls into the memory manager.</p>
</blockquote>

<p>But he also said:</p>

<blockquote>
  <p>Lest I start a panic, let me say that the goal in optimizing memory management is not to live an ascetic life free of distraction from the many useful C++ features that use dynamically allocated variables. Rather, the goal is to remove performance-robbing, unneeded calls into the memory manager through skillful use of these same features.</p>
</blockquote>

<h2 id="making-stdarray-and-small-vectors-your-second-option">Making <code class="language-plaintext highlighter-rouge">std::array</code> and small vectors your second option</h2>

<p>Well, talk is cheap, let’s see some real C++ codes.</p>

<h3 id="introducing-stdarray">Introducing <code class="language-plaintext highlighter-rouge">std::array</code></h3>

<p>Standard array occupies stack memory (or static memory if static-storage).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ill. triggers dynamic allocation.</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">ill_vec</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>

<span class="c1">// better (remember to include &lt;experimental/array&gt;)</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">good_vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">make_array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

<span class="c1">// way better</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">better_vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">make_array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</code></pre></div></div>

<p>Limitation of <code class="language-plaintext highlighter-rouge">std::array</code>:</p>

<ul>
  <li>Size are statically fixed:
    <ul>
      <li>Limited initialization;</li>
      <li>Cannot append or fallback to dynamic vector;</li>
      <li>No capacity-size support;</li>
    </ul>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// illegal</span>
<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="p">{};</span>

<span class="c1">// correct</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1000</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="p">{};</span>
</code></pre></div></div>

<p>To resolve these issues, try small vectors <code class="language-plaintext highlighter-rouge">boost::container::small_vector</code>.</p>

<h3 id="small-vectors">Small vectors</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Try this on: https://wandbox.org/</span>

<span class="cp">#include &lt;boost/container/small_vector.hpp&gt;
#include &lt;boost/range/irange.hpp&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">small_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">small_vec</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">irange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">small_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">small_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">small_vec</span><span class="p">);</span> 
    <span class="c1">// 56 = sizeof(ptr) + sizeof(size) + sizeof(capacity) + 8 * sizeof(int) </span>
    <span class="c1">//    = 8           + 8            + 8                + 8 * 4</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>Looks quite like a vector right? In fact, a small vector like <code class="language-plaintext highlighter-rouge">small_vector&lt;int, 8&gt;</code> is consist of:</p>

<ul>
  <li>for stack array usage: 8 int on the stack. if size &lt;= 8;</li>
  <li>for full-vector fallback: fallback to a normal vector if size &gt; 8;</li>
</ul>

<p>If your data distribution is like: most <code class="language-plaintext highlighter-rouge">data.size()</code> &lt;= 8, you definitely wanna try a small vector since it can prevent your most of your data being shipped to the heap.</p>

<h3 id="benchmark">Benchmark</h3>

<p>We compare the <code class="language-plaintext highlighter-rouge">push_back</code> efficiency among some <code class="language-plaintext highlighter-rouge">std::vector</code> and <code class="language-plaintext highlighter-rouge">boost::container::small_vector</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;benchmark/benchmark.h&gt;
#include &lt;boost/container/small_vector.hpp&gt;
#include &lt;boost/range/irange.hpp&gt;
</span>
<span class="cp">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">workload</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono_literals</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mx">100ms</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">n_workload</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n_workload</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">gen</span> <span class="p">{</span> <span class="n">rd</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chi_squared_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="mf">8.</span><span class="p">);</span>
    <span class="c1">// see https://en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dataset size distribution:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">irange</span><span class="p">(</span><span class="n">n_workload</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">'\t'</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}();</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">PushBackSmallVecBench</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">_</span> <span class="o">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">workload</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">small_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">irange</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">PushBackStdVecBench</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">_</span> <span class="o">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">workload</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
            <span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">irange</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackSmallVector_BaseSize8</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackSmallVecBench</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackSmallVector_BaseSize12</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackSmallVecBench</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackSmallVector_BaseSize16</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackSmallVecBench</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackSmallVector_BaseSize32</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackSmallVecBench</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackVector_BaseSize0</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackStdVecBench</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackVector_BaseSize8</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackStdVecBench</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackVector_BaseSize12</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackStdVecBench</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackVector_BaseSize16</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackStdVecBench</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PushBackVector_BaseSize32</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="n">PushBackStdVecBench</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// Register the function as a benchmark</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackVector_BaseSize0</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackVector_BaseSize8</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackSmallVector_BaseSize8</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackVector_BaseSize12</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackSmallVector_BaseSize12</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackVector_BaseSize16</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackSmallVector_BaseSize16</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackVector_BaseSize32</span><span class="p">);</span>
<span class="n">BENCHMARK</span><span class="p">(</span><span class="n">PushBackSmallVector_BaseSize32</span><span class="p">);</span>

<span class="c1">// Run the benchmark</span>
<span class="n">BENCHMARK_MAIN</span><span class="p">();</span>
</code></pre></div></div>

<p>The logic of the benchmark is to create a “length set” which follows <a href="https://en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution">Chi Squared distribution (dof = 8)</a>. For each benchmark case, we let the (small) vector to append values in that length and see its efficiency. The difference among those cases are:</p>

<ol>
  <li>Type: small vector or standard vectors;</li>
  <li>Pre-allocated size:
    <ol>
      <li>for <code class="language-plaintext highlighter-rouge">std::vector</code> we use <code class="language-plaintext highlighter-rouge">.reserve</code> to reserve some heap memory;</li>
      <li>for <code class="language-plaintext highlighter-rouge">boost::container::small_vector</code> we simply leverage the pre-allocated stack buffer as the reserved memory.</li>
    </ol>
  </li>
</ol>

<p>The results:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dataset size distribution:
5	9	10	5	10	5	6	10	5	5	6	2	6	4	8	8	4	12	13	5	
4	13	14	5	10	11	0	10	13	3	16	5	4	3	10	6	3	18	6	13	
5	16	14	25	1	10	3	7	7	14	9	11	12	7	14	7	9	4	8	5	
8	4	9	8	7	19	7	11	6	7	2	2	9	7	4	8	4	8	7	4	
8	3	7	14	2	6	8	4	5	3	8	6	7	2	9	7	8	9	7	14	
2021-07-10T14:33:01+08:00
Running /Users/ganler-mac/CLionProjects/PlayBoost/cmake-build-release/PlayBoost
Run on (8 X 2200 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB (x4)
  L1 Instruction 32 KiB (x4)
  L2 Unified 256 KiB (x4)
  L3 Unified 6144 KiB (x1)
Load Average: 3.08, 3.10, 3.03
-------------------------------------------------------------------------
Benchmark                               Time             CPU   Iterations
-------------------------------------------------------------------------
PushBackVector_BaseSize0            56440 ns        56058 ns        12727
PushBackVector_BaseSize8            18255 ns        17942 ns        40257
PushBackSmallVector_BaseSize8        9183 ns         9000 ns        96773
PushBackVector_BaseSize12           21918 ns        20460 ns        34947
PushBackSmallVector_BaseSize12       6073 ns         5211 ns       100000
PushBackVector_BaseSize16           13196 ns        12863 ns        44217
PushBackSmallVector_BaseSize16       1776 ns         1753 ns       371258
PushBackVector_BaseSize32           12384 ns        12059 ns        78193
PushBackSmallVector_BaseSize32       2435 ns         2104 ns       336143
</code></pre></div></div>

<p>Conclusions:</p>

<ol>
  <li>reserved memory is faster;</li>
  <li>stack memory is faster;</li>
  <li>those whose reserved memory size is closer to the distribution is faster;</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<ol>
  <li>Use stack memory if you can (but watch out stack overflow, so do it for small objects);</li>
  <li>Even if in your case stack memory is not applicable (to avoid stack overflow), try to reserve some;</li>
  <li>See if your data has some kind of distribution and reserve memory according to it;</li>
</ol>

<hr />

<p>To extend:</p>

<p><a href="https://en.wikipedia.org/wiki/Variable-length_array">VLA (variable-length array)</a> is a technique to allocate user-space stack memory of arbitrary size. This is a standard for C99 but not for C++.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// for C99 standard.</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</code></pre></div></div>

<p>Some points regarding VLA:</p>

<ul>
  <li>Fast:
    <ul>
      <li>Can be allocated on the stack (for most time).</li>
    </ul>
  </li>
  <li>Slow:
    <ul>
      <li>Much more instructions compared with fixed-size array allocation since it requires some additional instructions to adjust stack size. See <a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/11/Making-C-Less-Dangerous-3.pdf">slide 9 of Kees’ presentation</a>.</li>
      <li>(In general cases) may not be allocated right after your physical-space stack since the size is variable and the underlying implementation might simply allocate in somewhere else and virtually “concat” it with your old stack.</li>
    </ul>
  </li>
  <li>Dangerous:
    <ul>
      <li>Since it is not restricted, it is a blazing-fast trap to trigger stack overflow.</li>
    </ul>
  </li>
</ul>

    
    <br/>
    <div style="margin-bottom: 5em;"></div>


        </div>
        <div class="col-sm-2">
          <div class="pane-separator hidden-xs" style="margin-bottom:30em;"></div>
          <div class="pane-separator visible-xs" style="margin-bottom:5em;"></div>
          <div class="right-pane" style="margin-left: 1em;">
            
              <div class="avatar">
                <center>
                  
                    <img src="/assets/img/avatar.jpg" alt="me" class="avatar-image">
                  
                  
                    <p class="avatar-description">So high, so low, so many things to know</p>
                  
                  <div class="right-links">
                    
<a href="https://github.com/ganler" target="_blank">
  <i class="fa fa-github fa-3x"></i>
</a>


<a href="mailto:jaway.liu {AT} ${GOOGLE_SUFFIX} ">
  <i class="fa fa-envelope fa-3x"></i>
</a>



<a href="https://twitter.com/JWLiu10" target="_blank">
  <i class="fa fa-twitter fa-3x"></i>
</a>


<a href="https://www.linkedin.com/in/jiawei-liu-079a00197" target="_blank">
  <i class="fa fa-linkedin fa-3x"></i>
</a>


                  </div>
                </center>
              </div>
            
            
              <div class="posts-list">
                <a href="/blog">
                  <h4>Recent Posts:</h4>
                </a>
                <ul>
                  
                </ul>
              </div>
            
          </div>
        </div>
      </div>
    </section>
    <section class="footer">
      <footer class="page-footer">
  <center>
    
    <div class="row">
      <div class="col-sm-8 col-sm-offset-2">
        <a onclick="toggleTheme();">
          Light/Dark
        </a>
      </div>
    </div>
    
    <div class="row">
      <div class="col-sm-8 col-sm-offset-2">
        
<a href="https://github.com/ganler" target="_blank">
  <i class="fa fa-github fa-3x"></i>
</a>


<a href="mailto:jaway.liu {AT} ${GOOGLE_SUFFIX} ">
  <i class="fa fa-envelope fa-3x"></i>
</a>



<a href="https://twitter.com/JWLiu10" target="_blank">
  <i class="fa fa-twitter fa-3x"></i>
</a>


<a href="https://www.linkedin.com/in/jiawei-liu-079a00197" target="_blank">
  <i class="fa fa-linkedin fa-3x"></i>
</a>


      </div>
    </div>
    
    <div class="row">
      <div class="col-sm-8 col-sm-offset-2">
        Copyright (c) 2021 Jiawei LIU's Homepage -
        <a href="mailto:jaway.liu {AT} ${GOOGLE_SUFFIX} ">&lt;jaway.liu {AT} ${GOOGLE_SUFFIX} &gt;</a>
      </div>
    </div>
    
  </center>
</footer>

    </section>
  </div>
</body>

</html>
